1.	当前数据库分类？什么是关系型数据库？什么是非关系型数据库？
当前数据库分类：层次式数据库、网络式数据库、关系式数据库和对象式数据库。

关系型数据库：
关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。

非关系型数据库：
（1）键值存储数据库（key-value）
键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。
键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。
典型产品：Memcached、Redis、MemcacheDB
（2）列存储（Column-oriented）数据库
列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓名和年龄会被放到一个列族中，薪资会被放到另一个列族中。
这种数据库通常用来应对分布式存储海量数据。
典型产品：Cassandra、HBase
（3）面向文档（Document-Oriented）数据库
文档型数据库的灵感是来自于Lotus Notes办公软件，而且它同第一种键值数据库类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。
面向文档数据库会将数据以文档形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或JSONB等多种形式存储。
典型产品：MongoDB、CouchDB
（4）图形数据库
图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。
典型产品：Neo4J、InforGrid
2.	Select语句的查询：根据业务需求写查询语句？
select 结果集显示的字段列表  from  所查询表的列表 where 查询条件语句;
在结果集后面使用as（mysql） 可以给查到的字段起一个别名   oracle不使用as  直接空格 别名
3.	Orale数据库中单引号和双引号区别？
均表示字符串， 双引号 表示 内部字符串严格区分大小写，用作特殊字符或关键字，被当作列处理 ，将非法格式符包装起来
单引号 表示字符串常量 字符串中双引号为字符串处理，用单引号标识 ，表识一个单引号
4.	数据库查询语句中对于null的处理？运算表达式中null值处理（mysql和oracle不同）
会额外加一段 and 或 or 判断该数据是否为null  （is null ）
5.	Distinct关键字的用法？
用在结果集显示的字段前，去重功能 ；
用在 函数方法中 （distinct 字段） 去重功能
6.	查询结果如何排序？asc/desc、多字段排序
select 结果集显示的字段列表  from  所查询表的列表 where 查询条件语句
order by 排序字段1 asc/desc , 排序字段2 asc/desc, 排序字段3 asc/desc ;
对查询结果集可以使用order by 进行排序；asc正序 dasc倒序
7.	Mysql如何将两个字段连接到一起？
Mysql/Oracle：concat（字段1，字段2……）
Oracle: 字段1||’ ’||字段2
SQL Server：字段1+’ ’+字段2
8.	数据库常用函数：字符串函数，数值函数，日期函数；三者之间的转换函数（MySQL和oracle）
to_char 将日期、数值转换为指定格式的字符串；
to_number 将字符串转换为数值类型；
to_date 将指定格式的字符串转换为日期类型；
注意：
           日期格式通配符；
           分钟是MI表示和java不同；
           数字格式通配符；注意 使用 9 表示一个数字；
           数值通配符中的位数要大于被转化的数的位数；
           函数的字符串参数都是使用单引号引出；
9.	Oracle的通用函数:nvl（重点掌握）、nvl2、case/when、decode函数
nvl(expr,value) 如果expr表达式为null，则使用value值；（把null值专为指定的value值）
 在oralce中含有null值的表达式的结果都是null值，也就是说其他的数值与null进行运算结果都是null值；
可以使用nvl进行转换处理；   
nvl2(expr,value1,value2) if expr != null,return value1,else return value2;

条件表达式函数：
      case函数：
          语法：
               类似于java的switch-case用法：（做等值匹配）
               case 字段或者表达式  when 匹配值  then 返回值
                                    when 匹配值  then  返回值
                                    else 返回值
                                    end
                                         
               类似于java的if-else写法：
               case when 判定表达式  then 返回值
                    when 判定表达式  then 返回值
                    else 返回值
                    end   
          
      decode函数：
          语法：是case函数的switch-case方式的简写形式；
               decode(字段或者表达式,匹配值1,返回值1,匹配值2,返回值2,匹配值n,返回值n,else返回值)


10.	什么是外连接？有几种？【提示：左外连接，右外连接，全外连接】笛卡尔连接也是外连接，不常用
左侧作为主表进行拼配，右侧没有匹配记录时就提供一个空行） 右外连接 全外连接（全外连接是将右外连接和左外连接的结果进行合并，并剔除重复的记录） （不常用笛卡尔连接 也是外连接 
在进行查询操作时，需要使用两个或者多个表之间的数据进行组合查询；  根据多表之间关联条件的关联方式：
11.	什么是等值连接？常用的等值连接有几种？【where等值连接，join-on等值连接，自然等值连接，using等值连接】
多表查询连接条件采用等值方式。where条件中用两个表的连接字段进行等值条件过滤；连接字段间用and 即可 
使用join on等值连接 
使用using子句的等值连接
          因为自然连接会默认使用所有的同名的字段作为连接条件，不够灵活；
自连接
          一个表自己同自己的等值连接叫做自连接；
          一般自连接发生在同一个表中的不同字段之间等值关联连接；
12.	什么是不等连接，不等值链接的作用？举例说明
不等值连接是指连接条件不是等值运算，一般使用between and 作为连接运算条件；
13.	什么是分组查询？分组函数【count、sum、avg、max、min。注：分组查询函数会自动过滤null值，可以用nvl进行预处理】
分组函数是多行函数，是处理多条数据记录，获取一个函数计算结果；
sum ：求和
 avg ：平均
max ：最大值
min ：最小值
count ：统计个数
14.	如何进行分组查询？group by如何使用？什么是having语句，如何使用？
分组查询就是使用分组字段将数据分成若干组，然后每一组再单独进行处理输出一个结果作为查询结果集中的一部分
 
  select 显示字段列表 from 被查询列表 where 查询过滤条件 group by 分组字段列表 having 分组过滤条件  order by 排序字段列表
解析：
   group by 后面的字段是分组字段，做为分组标准
   having 后面的过滤条件是对 group by 分组之后的各组数据的过滤处理；
   having中的过滤条件中只能包含分组函数或者是分组字段列表中的字段；
   
  显示字段类表在含有分组函数或者分组查询时，要求所显示的字段必须是分组函数结果、在分组字段列表中出现的字段
   不能是其他的字段； 也就是显示字段来自于分组函数或者group by之后的分组字段列表；
   
  补充：
   含有分组查询的语句的解析过程：
   （1） 先执行where条件过滤，获取要查询的集合；
   （2） 使用group by对where过滤之后的集合按照分组字段列表进行分组，获取若干组数据； 
  （3） 使用 having 对group by 分组之后的若干组数据进行过滤处理；
   （4） 如果现实字段列表中有分组函数，对 having过滤之后的若干组数据分进行组函数处理；
   （5） 对（4）结果集合进行order by 排序显示；
   
  原则：
   如果有多个过滤条件，这些过滤条件优先在where中进行处理，可以提高查询效率； 
  能写在where中的过滤条件就不要写在having中；
15.	分组查询需要注意的语法点：分组查询中select部分显示的字段，要么是分组函数要么是group by之后的子段，其他字段不可以；
16.	什么是子查询？exists关键字如何使用？
在查询语句中有使用了查询语句，就是子查询； 
  查询可以出现在 显示字段部分、from之后的被查询列表中、where条件中等；
  如果在查询出现在where条件部分，根据子查询结果集中的记录数可以分为多行子查询和单行子查询；
   多行子查询经常和操作符 in any all not 等配合；
   单行子查询经常和操作符 = > < >= <= <> 等配合；
   子查询要包含在括号内。
   将子查询放在比较条件的右侧。
   
  使用EXISTS关键字可以进行存在判定查询，EXISTS类似于java的if判定；
   EXISTS判定：
   EXISTS后面跟随一个判定子查询，根据子查询的查询结果只做判定处理（子查询作为if判定条件）
   判定标准：如果子查询结果不为空（查到了结果）则返回true；
   然后主查询根据EXISTS子查询判定的结果，来决定当前这条数据记录是不是要包含在结果集中；
   如果EXISTS子查询存在结果则返回true，与之对应的这条记录也放入查询结果中；
   
  NOT EXISTS：
   NOT EXISTS和EXISTS判定逻辑相反；
   判定标准：如果子查询没有查询结果（没有查到）则返回true；
   
  语法：
   select 显示字段列表 from 查询表列表 where exists(存在条件判定子查询语句)
   
  解析：
   if(存在条件判定子查询语句为true){
   当前的这条记录放入主查询select的结果集中
   }else{
   过滤舍弃当前这条记录
   }
17.	什么是多行子查询和单行子查询？【单行子查询使用exists关键字；多行子查询使用：in,any,all,>,=,<】
如果在查询出现在where条件部分，根据子查询结果集中的记录数可以分为多行子查询 和单行子查询
18.	****Rowid和rownum伪列对象的异同点？
19.	常用的集合操作有哪些?
20.	Oracle和mysql分页查询如何实现？【oracle：集合操作；rowid伪对象+子查询；mysql：limit关键字】
21.	DML操作中，delete与truncate的异同点？
22.	DML操作是受事务管理的；
23.	什么是事务？事务的特点？【CADI各表示什么？】
数据库事务是进行数据库操作时，分为若干步完成，这几步操作是作为一个整体进行管理，
   这就是一个事务；
   事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

（1）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
   （2）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
   （3）隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆， 必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
   （4）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
24.	****事物的隔离级别？每个隔离级别可能产生的问题？顺序读是安全的。
读未提交 脏读 读提交就可以解决
   读已提交 一个事物要等 另一个事物读完后 才能读 不可重复读 重复读就可以
   重复读 重复读 会出现幻读 幻读对应的是 插入操作 
  顺序读 事务串行化顺序执行，可以避免脏读、不可重复读与幻读
25.	DDL五大常用约束？非空约束，主键约束，唯一约束，外键约束，自定义check约束；
26.	了解一下权限，角色，如何创建oracle用户？如何赋予权限和剥夺权限？权限的传递性？

Oracle对象的使用
27.	什么是视图？如何创建视图？视图和物理表之间有什么差异？
图是数据库用于展示数据的一种逻辑结构，
   视图一种缓存，将查询结果集缓存起来作为一个逻辑表使用，使用方式和物理表一样；（存储数据的表是物理结构）
   展示数据；（将查询结果以视图的形式进行展示）
   隐藏数据;（因为视图是以查询结果为基础构建的逻辑表，所以视图中所展示的内容都是经过处理，不需要展示的数据可以不出现）
   
  对于使用频次比较高的一些子查询可以创建为视图，提高执行效率；
28.	什么是序列？
oracle 序列 是一个单独的对象，是一个计数器 ，只能向上增 ，一般用于创建主键
   序列是按照设定的步长从初始值自增的一个计数器；
   注意：
   计数器每次都获取下一个值；
   计数器只能向前取值；
   计数器有两个伪对象：
   nextval：下一个值；
   currval：当前的值；
   
  计数器第一次使用时应先调用nextval获取下一个值，然后再使用currval获取当前值； 
    一般一个序列是为一个表中的一个字段提供自增数值服务；
   不建议多个字段或者是多个表公用一个序列（除业务需求之外）
29.	什么是索引？索引的作用？索引在什么情况下可以使用？什么情况下不建议使用？
索引是数据库的一个对象，用于提高查询速度，类似于书籍的目录
  数据库会给主键或者唯一键自动创建索引；
   需要创建索引的情况： 
  • 列中数据值分布范围很广
   • 列中包含大量空值
   • 列经常在WHERE 子句或连接条件中出现
   • 表经常被访问而且数据量很大，访问的数据大概占数据总量的2%到4%
   不需要创建索引的情况：
   • 表数据量很小
   • 列不经常作为连接条件或出现在WHERE子句中
   • 查询的数据大于2%到4%
   • 表经常更新（表更新时索引也需要同步更新，占用系统开销）
30.	什么是存储过程？什么是函数？有什么异同点？参数的类型有哪些？【提示：out，in，inout三种类型】
存储过程是pl编程中一段可以独立执行的程序代码，可以传递参数；
   
  函数 是pl编程中的可以独立执行的一段程序代码，可以传递参数；
   pl/sql编程，oracle数据库独有的，面向过程的sql编程
   
  存储过程和函数区别：
   存储过程没有返回值；
   函数可以有返回值；
   
  传递的参数有三种类型：
   in类型：默认的；
   只能从外往里传值；
   out类型：
   只能从里往外传值；
   in out类型： 
  可以从里往外传值也可以从外往里传值；
31.	什么是触发器？什么是游标？如何使用？
触发器分类：
      系统触发器；系统操作
      insteadof触发器；视图操作
      dml触发器；增删改操作
  触发器根据触发动作的粒度分为；
      语句级触发器；
      行级触发器；
		

    游标分为隐式游标和显式游标
  隐式游标使用以下几个变量获取游标参数：
    %FOUND 布尔型属性,当最近一次读记录时成功返回，则值为TRUE；
    %NOTFOUND 布尔型属性,与%FOUND相反，没有数据；
    %ISOPEN 布尔型属性, 取值总是FALSE。SQL命令执行完毕立即关闭隐式游标。
    %ROWCOUNT   数字型属性, 返回已从游标中读取得记录数；
    
  显式游标的使用：
    1、定义游标：
                CURSOR cursor_name IS select_statement
    2、打开游标
                OPEN cursor_name
    3、提取游标：就是检索结果集合中的数据行，放入指定的输出变量中。
                FETCH cursor_name INTO {variable_list | record_variable }
    4、关闭游标
                CLOSE cursor_name
32.	Oracle数据库如何实现主键字段值自增？【Oracle：序列+触发器（还有其他方式）；msql：自增属性】
Oracle数据库不能实现主键字段的自增，mysql、SQLServer可以实现主键字段自增；
Oracle中可以使用序列和触发器相结合的方式实现主键字段的自增；
Oracle：
-- 为主键字段创建自增主键
--- 创建自增主键字段的序列
create sequence seq_tuserInfo_user_id 
       --start with 1  --- 起始值  默认为 1 
       --increment by 1 --- 自增步长 默认步长为1
       --nomaxvalue --- 没有最大值 默认为nomaxvalue
       --nocycle --- 不循环 默认为 nocycle
       --nocache  --- 不使用缓存 默认为 nocache
       
--- 创建自增主键字段的触发器
create or replace trigger trigger_tuserInfo_user_id 
before insert on tuserInfo
for each row
  begin
    -- 使用new伪对象，在插入之前将序列提供的值 赋值给表 dept100的主键字段
    select seq_tuserInfo_user_id.nextval into :new.user_id from dual;
  end;
  
-- 插入数据
insert into  tuserInfo(user_name,user_psw)  values('admin', 'admin');
insert into  tuserInfo(user_name,user_psw)  values('user01', 'user01');
commit;
33.	备份与还原？
逻辑备份：
      使用imp/exp命令进行备份；
      需要在dos命令窗口下执行；
      
使用plsql客户端工具进行备份；
   注意：
      使用哪种方式进行导出备份的，需要使用与之对应的方式进行导入恢复；

34.	**（重要）**你在项目中有没有做过数据库可优化？【oracle与myql分别说明】【一定要提前准备说明】※※※
35.	什么是范式？经常用的有哪些？
1 NF：第一范式，在关系模式中每个属性值都是不可再分的最小数据单位；
2 NF：第二范式，首先必须满足第一范式，其次，在关系模式中，所有非主键字段完全依赖于任意一个主关键字，即不存在依赖组合关键字中的部分关键字的情况。特例是，如果是单关键字，必然至少是2 NF。
3 NF：第三范式，在关系模式中，不存在依赖传递，不存在非主关键字之间的依赖关系，即某个属性既依赖于主键，又同时依赖于其他非主关键字。

关系模式的规范化的优缺点
	优点：避免了大量的数据冗余，节省了空间，保持了数据的一致性，如果完全达到3NF，不会在超过一个地方更改同一个值。如果记录经常地改变，这个优点超过所有可能的缺点。
	缺点：把信息放置在不同的表中，增加了操作的难度，同时把多个表连接在一起的花费也是巨大的，性能也会有所影响。
	几个结论：
只要存在主键，关系模式至少为1NF。
	若关系模式为1NF，而主键只含2一个属性，则关系模式为2NF。
	若关系模式为2NF，而只有1个或0个非主属性，则关系模式为3NF。
	范式并非越高越好，适可而止。

36.	数据库死锁？加锁粒度？
37.	分页查询？
   分页查询就是一次查询部分指定范围的数据；
   分页查询的实现方式：
2.1 使用rownum伪列进行分页查询
rownum伪列是一个Oracle数据提供的虚拟列值，用于标识查询结果集中的每条记录的序号；
   		rownum伪列只能从1开始，不能从其他值开始；
		--- 使用子查询固化rownum伪列，然后在进行查询
select * from (
        select rownum rr,e.* from employees e where rownum <=20) tt
where tt.rr > 10;
2.2 使用集合操作（减集操作）
        --- 使用集合操作（减集）进行分页操作
select rownum rr,e.* from employees e where rownum <=20
minus
select rownum rr,e.* from employees e where rownum <=10
2.3 mysql使用limit关键字进行分页操作，但是Oracle数据不支持limit关键字；
-- 分页：查询1-10条记录
select * from core_user where  1=1 limit 0,10;
-- 分页：查询11-20条记录
select * from core_user where  1=1 limit 10,10;
--上面代码需要在mysql下执行。
